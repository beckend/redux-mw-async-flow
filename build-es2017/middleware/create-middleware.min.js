const tslib_1=require("tslib");const request_store_1=require("../request-store");const async_types_1=require("../async-types");const promise_factory_1=require("../promise-factory");const middleware_observers_1=require("./middleware-observers");const Observable_1=require("rxjs/Observable");exports.Observable=Observable_1.Observable;const Subject_1=require("rxjs/Subject");exports.Subject=Subject_1.Subject;const merge=require("lodash.merge");const lSet=require("lodash.set");const lGet=require("lodash.get");
const uniqueid=require("uniqueid");const asyncUniqueId=uniqueid(null,"-@@ASYNC_FLOW");exports.defaultOpts={metaKey:"asyncFlow",metaKeyRequestID:"REQUEST_ID",timeout:1E4,generateId:({action})=>`${asyncUniqueId()}--${action.type}`};
exports.createAsyncFlowMiddleware=(opts={metaKey:exports.defaultOpts.metaKey,timeout:exports.defaultOpts.timeout})=>{const {REQUEST,PENDING,FULFILLED,REJECTED,ABORTED,END}=async_types_1.getAsyncTypeConstants({types:opts.asyncTypes});const mwObservers=middleware_observers_1.createObservers({asyncTypes:{REQUEST,END}});const {metaKey,timeout,metaKeyRequestID,generateId}=tslib_1.__assign({},exports.defaultOpts,opts);const requestStore=new request_store_1.RequestStore;const middleware=()=>{return(next)=>
{return(action)=>{const dispatchNormal=()=>next(action);const dispatchAsyncFlow=(actionArg)=>{mwObservers.before.rootSubject.next(actionArg);const dispatchResult=next(actionArg);mwObservers.after.rootSubject.next(dispatchResult)};const actionType=action.type;if(lGet(action,["meta",metaKey,"enable"])===false){dispatchNormal();return}const metaRequestIdPath=["meta",metaKey,metaKeyRequestID];let actionEnd;const handleEndAction=(suffixType,resolve,payloadArg)=>{const requestID=lGet(action,metaRequestIdPath);
if(requestID){if(resolve)requestStore.resolve(requestID,payloadArg||action.payload);else requestStore.reject(requestID,payloadArg||action.payload);actionEnd=merge({},action,{type:async_types_1.replaceSuffix(actionType,suffixType,END)})}else console.warn(`${action.type} - meta data not found, did you forget to send it?`)};if(actionType.endsWith(REQUEST)){let requestID=lGet(action,metaRequestIdPath);if(!requestID||{}.hasOwnProperty.call(requestStore,requestID)){do requestID=generateId({action});while({}.hasOwnProperty.call(requestStore,
requestID));lSet(action,metaRequestIdPath,requestID)}const metaTimeoutKey=lGet(action,["meta",metaKey,"timeoutRequest"]);const timeoutRequest=metaTimeoutKey||timeout;const {promise,reject,resolve}=promise_factory_1.createPromise();promise.timeout(timeoutRequest,"timeout").catch((er)=>{reject(er)}).finally(()=>{requestStore.delete(requestID)});const tmpRequestStoreAddPayload={[request_store_1.REQUEST_KEY_PROMISE]:promise,[request_store_1.REQUEST_KEY_RESOLVEFN]:resolve,[request_store_1.REQUEST_KEY_REJECTFN]:reject};
requestStore.add(requestID,tmpRequestStoreAddPayload);const addedActionMetaData={meta:{[metaKey]:{timeout,timeoutRequest,promise}}};const pendingAction=merge({},action,{type:async_types_1.replaceSuffix(actionType,REQUEST,PENDING)},addedActionMetaData);dispatchAsyncFlow(pendingAction);const newAction=merge({},action,addedActionMetaData);dispatchAsyncFlow(newAction);return}else if(actionType.endsWith(FULFILLED))handleEndAction(FULFILLED,true);else if(actionType.endsWith(REJECTED))handleEndAction(REJECTED,
false);else if(actionType.endsWith(ABORTED))handleEndAction(ABORTED,false);else{dispatchNormal();return}dispatchAsyncFlow(action);if(actionEnd)dispatchAsyncFlow(actionEnd)}}};return{middleware,observers:mwObservers}};