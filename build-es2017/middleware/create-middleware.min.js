const tslib_1=require("tslib");const Observable_1=require("rxjs/Observable");exports.Observable=Observable_1.Observable;const Subject_1=require("rxjs/Subject");exports.Subject=Subject_1.Subject;const async_types_1=require("../async-types");const promise_factory_1=require("../promise-factory");const request_store_1=require("../request-store");const date_1=require("./date");const default_options_1=require("./default-options");const middleware_observers_1=require("./middleware-observers");
const merge=require("lodash.merge");const lSet=require("lodash.set");const lGet=require("lodash.get");const cloneDeep=require("lodash.clonedeep");const uniqueid=require("uniqueid");const getGenerateId=()=>{const asyncUniqueId=uniqueid(null,"-@@ASYNC_FLOW");return({action})=>`${asyncUniqueId()}--${action.type}`};
exports.createAsyncFlowMiddleware=(opts={metaKey:default_options_1.defaultOpts.metaKey,timeout:default_options_1.defaultOpts.timeout})=>{const {REQUEST,PENDING,FULFILLED,REJECTED,ABORTED,END}=async_types_1.getAsyncTypeConstants({types:opts.asyncTypes});const mwObservers=middleware_observers_1.createObservers({asyncTypes:{REQUEST,END}});const {metaKey,timeout,metaKeyRequestID,generateId:generateIdMerged}=tslib_1.__assign({},default_options_1.defaultOpts,opts);const generateId=generateIdMerged||getGenerateId();
const requestStore=new request_store_1.RequestStore;const middleware=()=>{return(next)=>{return(action)=>{const dispatchNormal=()=>next(action);const dispatchAsyncFlow=(actionArg)=>{mwObservers.before.rootSubject.next(actionArg);const dispatchResult=next(actionArg);mwObservers.after.rootSubject.next(dispatchResult)};const actionType=action.type;if(!actionType||lGet(action,["meta",metaKey,"enable"])===false){dispatchNormal();return}const metaRequestIdPath=["meta",metaKey,metaKeyRequestID];const metaPromisePath=
["meta",metaKey,"promise"];const handleEndAction=(suffixType,resolve,payloadArg)=>{const requestID=lGet(action,metaRequestIdPath);const theAsyncFlowPromise=lGet(action,metaPromisePath);if(!requestID||!theAsyncFlowPromise){dispatchNormal();return}else dispatchAsyncFlow(action);if(requestID){if(resolve)requestStore.resolve(requestID,payloadArg||action.payload);else requestStore.reject(requestID,payloadArg||action.payload);const actionEnd=merge({},action,{meta:{[metaKey]:{endActionType:actionType,timeEnd:date_1.newDate()}},
type:async_types_1.replaceSuffix(actionType,suffixType,END)});dispatchAsyncFlow(actionEnd)}else console.warn(`${action.type} - meta data not found, did you forget to send it?`)};if(actionType.endsWith(REQUEST)){const actionClone=cloneDeep(action);let requestID=lGet(actionClone,metaRequestIdPath);if(!requestID||{}.hasOwnProperty.call(requestStore,requestID)){do requestID=generateId({action:actionClone});while({}.hasOwnProperty.call(requestStore,requestID));lSet(actionClone,metaRequestIdPath,requestID)}const metaTimeoutKey=
lGet(actionClone,["meta",metaKey,"timeoutRequest"]);const timeoutRequest=metaTimeoutKey||timeout;const {promise,reject,resolve}=promise_factory_1.createPromise();promise.timeout(timeoutRequest,"timeout").catch((er)=>{reject(er)}).finally(()=>{requestStore.delete(requestID)});const tmpRequestStoreAddPayload={[request_store_1.REQUEST_KEY_PROMISE]:promise,[request_store_1.REQUEST_KEY_RESOLVEFN]:resolve,[request_store_1.REQUEST_KEY_REJECTFN]:reject};requestStore.add(requestID,tmpRequestStoreAddPayload);
const addedActionMetaData={meta:{[metaKey]:{endActionType:null,promise,timeEnd:null,timeStart:date_1.newDate(),timeout,timeoutRequest}}};const pendingAction=merge({},actionClone,{type:async_types_1.replaceSuffix(actionType,REQUEST,PENDING)},addedActionMetaData);dispatchAsyncFlow(pendingAction);const newAction=merge({},actionClone,addedActionMetaData);dispatchAsyncFlow(newAction);return}else if(actionType.endsWith(FULFILLED))handleEndAction(FULFILLED,true);else if(actionType.endsWith(REJECTED))handleEndAction(REJECTED,
false);else if(actionType.endsWith(ABORTED))handleEndAction(ABORTED,false);else dispatchNormal()}}};return{middleware,observers:{after:{obsOnAll:mwObservers.after.obsOnAll,obsOnEnd:mwObservers.after.obsOnEnd,obsOnRequest:mwObservers.after.obsOnRequest},before:{obsOnAll:mwObservers.before.obsOnAll,obsOnEnd:mwObservers.before.obsOnEnd,obsOnRequest:mwObservers.before.obsOnRequest}}}};