const tslib_1=require("tslib");const date_1=require("./date");const default_options_1=require("./default-options");const request_store_1=require("../request-store");const async_types_1=require("../async-types");const promise_factory_1=require("../promise-factory");const middleware_observers_1=require("./middleware-observers");const Observable_1=require("rxjs/Observable");exports.Observable=Observable_1.Observable;const Subject_1=require("rxjs/Subject");exports.Subject=Subject_1.Subject;
const merge=require("lodash.merge");const lSet=require("lodash.set");const lGet=require("lodash.get");const uniqueid=require("uniqueid");const getGenerateId=()=>{const asyncUniqueId=uniqueid(null,"-@@ASYNC_FLOW");return({action})=>`${asyncUniqueId()}--${action.type}`};
exports.createAsyncFlowMiddleware=(opts={metaKey:default_options_1.defaultOpts.metaKey,timeout:default_options_1.defaultOpts.timeout})=>{const {REQUEST,PENDING,FULFILLED,REJECTED,ABORTED,END}=async_types_1.getAsyncTypeConstants({types:opts.asyncTypes});const mwObservers=middleware_observers_1.createObservers({asyncTypes:{REQUEST,END}});const {metaKey,timeout,metaKeyRequestID,generateId:generateIdMerged}=tslib_1.__assign({},default_options_1.defaultOpts,opts);const generateId=generateIdMerged||getGenerateId();
const requestStore=new request_store_1.RequestStore;const middleware=()=>{return(next)=>{return(action)=>{const dispatchNormal=()=>next(action);const dispatchAsyncFlow=(actionArg)=>{mwObservers.before.rootSubject.next(actionArg);const dispatchResult=next(actionArg);mwObservers.after.rootSubject.next(dispatchResult)};const actionType=action.type;if(lGet(action,["meta",metaKey,"enable"])===false){dispatchNormal();return}const metaRequestIdPath=["meta",metaKey,metaKeyRequestID];let actionEnd;const handleEndAction=
(suffixType,resolve,payloadArg)=>{const requestID=lGet(action,metaRequestIdPath);if(requestID){if(resolve)requestStore.resolve(requestID,payloadArg||action.payload);else requestStore.reject(requestID,payloadArg||action.payload);actionEnd=merge({},action,{type:async_types_1.replaceSuffix(actionType,suffixType,END),meta:{[metaKey]:{endActionType:actionType,timeEnd:date_1.newDate()}}})}else console.warn(`${action.type} - meta data not found, did you forget to send it?`)};if(actionType.endsWith(REQUEST)){let requestID=
lGet(action,metaRequestIdPath);if(!requestID||{}.hasOwnProperty.call(requestStore,requestID)){do requestID=generateId({action});while({}.hasOwnProperty.call(requestStore,requestID));lSet(action,metaRequestIdPath,requestID)}const metaTimeoutKey=lGet(action,["meta",metaKey,"timeoutRequest"]);const timeoutRequest=metaTimeoutKey||timeout;const {promise,reject,resolve}=promise_factory_1.createPromise();promise.timeout(timeoutRequest,"timeout").catch((er)=>{reject(er)}).finally(()=>{requestStore.delete(requestID)});
const tmpRequestStoreAddPayload={[request_store_1.REQUEST_KEY_PROMISE]:promise,[request_store_1.REQUEST_KEY_RESOLVEFN]:resolve,[request_store_1.REQUEST_KEY_REJECTFN]:reject};requestStore.add(requestID,tmpRequestStoreAddPayload);const addedActionMetaData={meta:{[metaKey]:{timeout,timeoutRequest,promise,endActionType:null,timeStart:date_1.newDate(),timeEnd:null}}};const pendingAction=merge({},action,{type:async_types_1.replaceSuffix(actionType,REQUEST,PENDING)},addedActionMetaData);dispatchAsyncFlow(pendingAction);
const newAction=merge({},action,addedActionMetaData);dispatchAsyncFlow(newAction);return}else if(actionType.endsWith(FULFILLED))handleEndAction(FULFILLED,true);else if(actionType.endsWith(REJECTED))handleEndAction(REJECTED,false);else if(actionType.endsWith(ABORTED))handleEndAction(ABORTED,false);else{dispatchNormal();return}dispatchAsyncFlow(action);if(actionEnd)dispatchAsyncFlow(actionEnd)}}};return{middleware,observers:{before:{obsOnAll:mwObservers.before.obsOnAll,obsOnRequest:mwObservers.before.obsOnRequest,
obsOnEnd:mwObservers.before.obsOnEnd},after:{obsOnAll:mwObservers.after.obsOnAll,obsOnRequest:mwObservers.after.obsOnRequest,obsOnEnd:mwObservers.after.obsOnEnd}}}};