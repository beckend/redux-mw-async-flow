Object.defineProperty(exports,"__esModule",{value:true});const cloneDeep=require("lodash.clonedeep");const lGet=require("lodash.get");const merge=require("lodash.merge");const lSet=require("lodash.set");const Observable_1=require("rxjs/Observable");exports.Observable=Observable_1.Observable;const Subject_1=require("rxjs/Subject");exports.Subject=Subject_1.Subject;const async_types_1=require("../async-types");const promise_factory_1=require("../promise-factory");const request_store_1=require("../request-store");
const date_1=require("./date");const default_options_1=require("./default-options");const middleware_observers_1=require("./middleware-observers");const uniqueid=require("uniqueid");const getGenerateId=()=>{const asyncUniqueId=uniqueid(null,"-@@ASYNC_FLOW");return({action})=>`${asyncUniqueId()}--${action.type}`};
exports.createAsyncFlowMiddleware=(opts={metaKey:default_options_1.defaultOpts.metaKey,timeout:default_options_1.defaultOpts.timeout})=>{const {REQUEST,PENDING,FULFILLED,REJECTED,ABORTED,END}=async_types_1.getAsyncTypeConstants({types:opts.asyncTypes});const mwObservers=middleware_observers_1.createObservers({asyncTypes:{END,REQUEST}});const {generateId:generateIdMerged,metaKey,metaKeyRequestID,timeout}=Object.assign({},default_options_1.defaultOpts,opts);const generateId=generateIdMerged||getGenerateId();
const requestStore=new request_store_1.RequestStore;const middleware=()=>{return(next)=>{return(action)=>{const dispatchNormal=()=>next(action);const actionType=action.type;if(!actionType||lGet(action,["meta",metaKey,"enable"])===false)return dispatchNormal();const dispatchAsyncFlow=(actionArg)=>{mwObservers.before.rootSubject.next(actionArg);const dispatchResult=next(actionArg);mwObservers.after.rootSubject.next(dispatchResult);return dispatchResult};const metaRequestIdPath=["meta",metaKey,metaKeyRequestID];
const metaPromisePath=["meta",metaKey,"promise"];const handleEndAction=(suffixType,resolve)=>{const requestID=lGet(action,metaRequestIdPath);const theAsyncFlowPromise=lGet(action,metaPromisePath);if(!requestID||!theAsyncFlowPromise)return dispatchNormal();const dispatchResult=dispatchAsyncFlow(action);if(requestID){if(resolve)requestStore.resolve(requestID,action.payload);else requestStore.reject(requestID,action.payload);const actionEnd=merge({},action,{meta:{[metaKey]:{endActionType:actionType,
timeEnd:date_1.newDate()}},type:async_types_1.replaceSuffix(actionType,suffixType,END)});dispatchAsyncFlow(actionEnd)}else console.warn(`${action.type} - meta data not found, did you forget to send it?`);return dispatchResult};if(actionType.endsWith(REQUEST)){const actionClone=cloneDeep(action);let requestID=lGet(actionClone,metaRequestIdPath);if(!requestID||{}.hasOwnProperty.call(requestStore,requestID)){do requestID=generateId({action:actionClone});while({}.hasOwnProperty.call(requestStore,requestID));
lSet(actionClone,metaRequestIdPath,requestID)}const metaTimeoutKey=lGet(actionClone,["meta",metaKey,"timeoutRequest"]);const timeoutRequest=metaTimeoutKey||timeout;const {promise,reject,resolve}=promise_factory_1.createPromise();promise.timeout(timeoutRequest,"timeout").catch((er)=>{reject(er)}).finally(()=>{requestStore.delete(requestID)});const tmpRequestStoreAddPayload={[request_store_1.REQUEST_KEY_PROMISE]:promise,[request_store_1.REQUEST_KEY_RESOLVEFN]:resolve,[request_store_1.REQUEST_KEY_REJECTFN]:reject};
requestStore.add(requestID,tmpRequestStoreAddPayload);const addedActionMetaData={meta:{[metaKey]:{endActionType:null,promise,timeEnd:null,timeStart:date_1.newDate(),timeout,timeoutRequest}}};const pendingAction=merge({},actionClone,{type:async_types_1.replaceSuffix(actionType,REQUEST,PENDING)},addedActionMetaData);dispatchAsyncFlow(pendingAction);const newAction=merge({},actionClone,addedActionMetaData);return dispatchAsyncFlow(newAction)}else if(actionType.endsWith(FULFILLED))return handleEndAction(FULFILLED,
true);else if(actionType.endsWith(REJECTED))return handleEndAction(REJECTED,false);else if(actionType.endsWith(ABORTED))return handleEndAction(ABORTED,false);else return dispatchNormal()}}};return{middleware,observers:{after:{obsOnAll:mwObservers.after.obsOnAll,obsOnEnd:mwObservers.after.obsOnEnd,obsOnRequest:mwObservers.after.obsOnRequest},before:{obsOnAll:mwObservers.before.obsOnAll,obsOnEnd:mwObservers.before.obsOnEnd,obsOnRequest:mwObservers.before.obsOnRequest}}}};